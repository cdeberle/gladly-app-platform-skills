# Data Pull Templates

This reference covers patterns for data pull configurations and templates.

## Architecture: Combined vs Separate Data Pulls

### Combined Data Pull (Single Request)

All related data fetched in one API call:

```
┌─────────────────────────────────────────┐
│           customer_lookup               │
│  Returns: customer + orders + loyalty   │
└─────────────────────────────────────────┘
```

**Pros:**
- Fewer HTTP requests
- Simpler configuration
- All data available together

**Cons:**
- All-or-nothing: if one nested type fails, entire pull fails
- Less granular control for AI Action Adapter
- Harder to debug which part failed

**Use when:**
- External API returns all data in single response
- Data types are tightly coupled
- Don't need granular AI agent control

### Separate Data Pulls (Multiple Requests)

Each entity type has its own data pull:

```
┌─────────────────────┐
│   customer_lookup   │  (Root)
│   demo_crm_customer │
└─────────┬───────────┘
          │ dependsOnDataTypes
    ┌─────┼─────┬─────────┐
    ▼     ▼     ▼         ▼
┌───────┐┌───────┐┌───────────┐┌────────┐
│orders ││subscr.││reservations││loyalty │
└───────┘└───────┘└───────────┘└────────┘
```

**Pros:**
- Fault isolation: empty reservations don't break orders
- Granular AI Action Adapter control
- Easier to debug individual pulls
- Can add new data types independently

**Cons:**
- More HTTP requests
- More configuration files
- Need to handle dependencies correctly

**Use when:**
- Need granular control for AI agents
- Want fault isolation between data types
- Data types are logically independent
- Building for extensibility

---

## Directory Structure

```
data/pull/<type_name>/
├── config.json                  # Required: Data type, HTTP method, dependencies
├── request_url.gtpl             # Required: URL template
├── request_body.gtpl            # Optional: For POST/PUT requests
├── response_transformation.gtpl # Optional: Transform API response
├── external_id.gtpl             # Required: Extract entity ID
├── external_updated_at.gtpl     # Optional: Extract last updated timestamp
├── external_parent_id.gtpl      # Required for child types: Extract parent ID
└── _test_/
    └── default/
        ├── integration.json     # Test: Integration config
        ├── customer.json        # Test: Customer context (root pulls)
        ├── externalData.json    # Test: Parent data (dependent pulls)
        ├── rawData.json         # Test: API response
        ├── expected_request_url.txt
        └── expected_response_transformation.json
```

---

## Context Data Structures

Understanding what data is available in each template type is essential.

### request_url.gtpl and request_body.gtpl Context

```jsonc
{
    "integration": {
        // Dynamic configuration associated with the app platform app
        "configuration": {},
        // Secrets needed for making REST calls
        "secrets": {}
    },
    // Gladly customer profile data (all fields optional)
    "customer": {
        "id": "gladly-customer-profile-id",
        "name": "John Smith",
        "address": "123 Somewhere Street, CA, USA",
        "primaryEmailAddress": "john_smith@email.com",
        "emailAddresses": ["john_smith@gmail.com", "js@yahoo.com"],
        "primaryPhoneNumber": {
            "number": "+15551234567",  // E.164 format
            "type": "HOME|MOBILE|OFFICE|OTHER"
        },
        "phoneNumbers": [
            {
                "number": "+15551234567",
                "type": "HOME|MOBILE|OFFICE|OTHER"
            }
        ]
    },
    // Data from pulls this data pull depends on
    "externalData": {
        "dependent_data_type_name": [],
        "another_dependent_data_type_name": []
    }
}
```

**Important:** All customer fields are optional. Templates must check for presence before use. The most common response to missing data is `{{stop "message"}}`.

### response_transformation.gtpl Context

```jsonc
{
    "integration": {
        "configuration": {},
        "secrets": {}
    },
    "customer": {
        // Same structure as above
    },
    "externalData": {
        // Data from dependent data pulls
    },
    "request": {
        // The request URL as generated by request_url.gtpl
        "url": "",
        // The HTTP method from config.json
        "method": "",
        // Headers from authentication/headers/
        "headers": {
            "header_name": ["header value"]
        },
        // Raw bytes of the request body
        "body": ""
    },
    "response": {
        // HTTP response status text
        "status": "",
        // HTTP response status code
        "statusCode": 200,
        // Response headers
        "headers": {
            "response_header_name": ["header value"]
        },
        // Raw bytes of the response body
        "body": ""
    },
    // The raw response data to transform
    // - For JSON: object or array
    // - For XML: Gladly-specific XML DOM
    // - For rawResponse=true: byte array
    "rawData": {}
}
```

**Important:** Response transformation templates don't need to check `.response.statusCode` unless `rawResponse: true` is set in config.json. The platform only executes transformations when status is 200.

---

## config.json

### Root Data Pull

```json
{
  "dataType": {
    "name": "acme_customer",
    "version": "1.0"
  },
  "httpMethod": "GET"
}
```

### Dependent Data Pull

```json
{
  "dataType": {
    "name": "acme_order",
    "version": "1.0"
  },
  "httpMethod": "GET",
  "dependsOnDataTypes": ["acme_customer"]
}
```

### POST Request

```json
{
  "dataType": {
    "name": "acme_search_results",
    "version": "1.0"
  },
  "httpMethod": "POST",
  "contentType": "application/json"
}
```

### With Timeout

```json
{
  "dataType": {
    "name": "acme_order",
    "version": "1.0"
  },
  "httpMethod": "GET",
  "requestTimeout": 30000
}
```

---

## request_url.gtpl Patterns

### Root Data Pull (Customer Lookup by Email)

```go
{{- /* Look up customer by email address */}}
{{- if eq (len .customer.emailAddresses) 0}}
  {{- stop "Customer profile has no email addresses"}}
{{- end}}

{{- $email := ""}}
{{- if .customer.primaryEmailAddress}}
  {{- $email = .customer.primaryEmailAddress}}
{{- else}}
  {{- $email = index .customer.emailAddresses 0}}
{{- end}}

{{- $baseUrl := .integration.configuration.apiBaseUrl}}
{{$baseUrl}}/api/customers?email={{urlquery $email}}
```

### Root Data Pull (Customer Lookup by Phone)

```go
{{- /* Look up customer by phone number */}}
{{- if eq (len .customer.phoneNumbers) 0}}
  {{- stop "Customer profile has no phone numbers"}}
{{- end}}

{{- $phone := ""}}
{{- if .customer.primaryPhoneNumber}}
  {{- $phone = .customer.primaryPhoneNumber.number}}
{{- else}}
  {{- $phone = (index .customer.phoneNumbers 0).number}}
{{- end}}

{{- $baseUrl := .integration.configuration.apiBaseUrl}}
{{$baseUrl}}/api/customers?phone={{urlquery $phone}}
```

### Dependent Data Pull (with Safety Checks)

```go
{{- /* Fetch orders for customer - ALWAYS include safety checks */}}
{{- $customers := .externalData.acme_customer}}
{{- if not $customers}}
  {{- stop "No customer data available"}}
{{- end}}
{{- if eq (len $customers) 0}}
  {{- stop "Customer not found"}}
{{- end}}
{{- $customerId := (index $customers 0).id}}
{{- if not $customerId}}
  {{- stop "Customer ID is empty"}}
{{- end}}

{{- $baseUrl := .integration.configuration.apiBaseUrl}}
{{$baseUrl}}/api/customers/{{urlquery $customerId}}/orders
```

### Multiple Requests (Batch Lookup)

```go
{{- /* Generate multiple URLs - one per order to fetch products */}}
{{- range .externalData.acme_order}}
{{- range .lineItems}}
{{$.integration.configuration.apiBaseUrl}}/api/products/{{.productId}}
{{end}}
{{- end}}
```

---

## response_transformation.gtpl Patterns

### Handle Paginated vs Direct Array

```go
{{- if not .rawData}}
[]
{{- else}}

{{- /* Extract array from response */}}
{{- $items := list}}
{{- if kindIs "slice" .rawData}}
  {{- $items = .rawData}}
{{- else if hasKey .rawData "data"}}
  {{- $items = .rawData.data}}
{{- else if hasKey .rawData "results"}}
  {{- $items = .rawData.results}}
{{- end}}

{{- /* Handle empty array */}}
{{- if eq (len $items) 0}}
[]
{{- else}}
[
{{- range $i, $item := $items}}
{{- if $i}},{{end}}
{
  "id": "{{$item.id}}",
  "orderNumber": {{$item.orderNumber | toJson}},
  "status": "{{$item.status}}",
  "totalPrice": {{if $item.totalPrice}}{{$item.totalPrice}}{{else}}null{{end}},
  "orderDate": {{if $item.orderDate}}"{{$item.orderDate}}"{{else}}null{{end}},
  "customerId": "{{$item.customerId}}"
}
{{- end}}
]
{{- end}}
{{- end}}
```

### Format Address Object to String

```go
{{- $formattedAddr := "" -}}
{{- if $item.address -}}
  {{- if kindIs "string" $item.address -}}
    {{- $formattedAddr = $item.address -}}
  {{- else -}}
    {{- $addrParts := list -}}
    {{- if $item.address.name }}{{ $addrParts = append $addrParts $item.address.name }}{{ end -}}
    {{- if $item.address.address1 }}{{ $addrParts = append $addrParts $item.address.address1 }}{{ end -}}
    {{- if $item.address.address2 }}{{ $addrParts = append $addrParts $item.address.address2 }}{{ end -}}
    {{- $cityLine := "" -}}
    {{- if $item.address.city }}{{ $cityLine = $item.address.city }}{{ end -}}
    {{- if $item.address.state -}}
      {{- if $cityLine }}{{ $cityLine = printf "%s, %s" $cityLine $item.address.state }}{{ else }}{{ $cityLine = $item.address.state }}{{ end -}}
    {{- end -}}
    {{- if $item.address.zip }}{{ $cityLine = printf "%s %s" $cityLine $item.address.zip }}{{ end -}}
    {{- if $cityLine }}{{ $addrParts = append $addrParts $cityLine }}{{ end -}}
    {{- if $item.address.country }}{{ $addrParts = append $addrParts $item.address.country }}{{ end -}}
    {{- $formattedAddr = $addrParts | join ", " -}}
  {{- end -}}
{{- end -}}
```

### Convert Date to DateTime

```go
{{- /* Convert date-only to DateTime with timezone */}}
"startDate": {{if $item.startDate}}{{if contains "T" $item.startDate}}"{{$item.startDate}}"{{else}}"{{$item.startDate}}T00:00:00Z"{{end}}{{else}}null{{end}}
```

### Handle Nullable Fields

```go
"note": {{if $item.note}}{{$item.note | toJson}}{{else}}null{{end}},
"tags": {{if $item.tags}}{{$item.tags | toJson}}{{else}}null{{end}},
"metadata": {{if $item.metadata}}{{$item.metadata | toJson}}{{else}}null{{end}}
```

---

## XML DOM Handling

When an API returns XML (Content-Type: `text/xml` or `application/xml`), the `.rawData` field contains a Gladly XML DOM object instead of parsed JSON.

**Character encoding:** Only UTF-8 is supported.

### Document Object

The root `.rawData` contains a Document object:

| Field/Function | Description |
|----------------|-------------|
| `.Root` | Access the root XML element (Node) |
| `.XML()` | Returns the XML as a string |

### Node Object

Each XML element is a Node with these fields and functions:

| Field | Type | Description |
|-------|------|-------------|
| `.Document` | *Document | Reference to parent document |
| `.Parent` | *Node | Parent element node |
| `.Attributes` | []Attribute | Collection of element attributes |
| `.Children` | []Node | Collection of child elements |
| `.Text` | string | Text content of the node |

| Function | Description |
|----------|-------------|
| `.GetAttribute(name)` | Get specific attribute object |
| `.GetAttributeValue(name)` | Get attribute value as string |
| `.GetChild(name)` | Get first matching child element |
| `.GetChildren(name)` | Get all matching child elements |
| `.FirstChild()` | Access first child node |
| `.LastChild()` | Access last child node |
| `.PrevSibling()` | Navigate to previous sibling |
| `.NextSibling()` | Navigate to next sibling |
| `.FindByID(id)` | Find element by ID attribute |
| `.FindOneByName(name)` | Find first element with name (recursive) |
| `.FindByName(name)` | Find all elements with name (recursive) |

### Attribute Object

| Field | Description |
|-------|-------------|
| `.Name` | Attribute identifier |
| `.Value` | Attribute content |

### XML Transformation Example

Given this XML response:

```xml
<orders>
  <order id="123">
    <item>White T-Shirt</item>
    <price>29.99</price>
  </order>
  <order id="456">
    <item>Black Socks</item>
    <price>9.99</price>
  </order>
</orders>
```

Transform to JSON array:

```go
[
{{- range $index, $order := (.rawData.Root.GetChildren "order") }}{{if gt $index 0}},{{end}}
  {
    "id": "{{$order.GetAttributeValue "id"}}",
    "item": {{($order.GetChild "item").Text | toJson}},
    "price": {{($order.GetChild "price").Text}}
  }
{{- end}}
]
```

### Testing XML Responses

For test fixtures with XML responses, use `.xml` file extension instead of `.json`:

```
_test_/xml_response/
├── rawData.xml              # XML response (not .json)
├── expected_response_transformation.json
```

---

## external_id.gtpl

Extract the unique identifier for the entity:

```go
{{.id}}
```

For numeric IDs (preserve formatting):

```go
{{int64 .id}}
```

---

## external_parent_id.gtpl

Extract the parent's ID from a child entity:

```go
{{.customerId}}
```

---

## external_updated_at.gtpl

Extract the last updated timestamp for cache/sync purposes. This template enables the platform to track when records were last modified and avoid unnecessary re-fetching of unchanged data.

```go
{{.updatedAt}}
```

For APIs that provide Unix timestamps:

```go
{{.lastModified | date "2006-01-02T15:04:05Z07:00"}}
```

**Important:** Output must be in ISO8601 format. If the API returns a different format, convert it:

```go
{{- /* Convert "2024-01-15" to ISO8601 DateTime */}}
{{- if .modifiedDate}}{{.modifiedDate}}T00:00:00Z{{end}}
```

---

## Test Fixtures

### integration.json

```json
{
  "configuration": {
    "apiBaseUrl": "https://api.acme.com/v1"
  },
  "secrets": {
    "apiToken": "test-token-123"
  }
}
```

### customer.json (for root pulls)

```json
{
  "id": "gladly-profile-123",
  "primaryEmailAddress": "test@example.com",
  "emailAddresses": ["test@example.com", "alt@example.com"],
  "primaryPhoneNumber": {
    "number": "+15551234567",
    "type": "MOBILE"
  },
  "phoneNumbers": [
    {"number": "+15551234567", "type": "MOBILE"}
  ]
}
```

### externalData.json (for dependent pulls)

```json
{
  "acme_customer": [
    {
      "id": "cust_123",
      "email": "test@example.com",
      "fullName": "Test User"
    }
  ]
}
```

### rawData.json

```json
{
  "data": [
    {
      "id": "order_456",
      "orderNumber": "ORD-001",
      "status": "delivered",
      "totalPrice": 99.99,
      "orderDate": "2024-01-15T10:30:00Z",
      "customerId": "cust_123"
    }
  ]
}
```

---

## Common Safety Functions

| Function | Purpose | Example |
|----------|---------|---------|
| `stop "message"` | Halt with error | `{{stop "No customer data"}}` |
| `urlquery` | URL encode value | `{{urlquery $email}}` |
| `default` | Provide fallback | `{{.value \| default ""}}` |
| `kindIs` | Check type | `{{if kindIs "slice" .data}}` |
| `hasKey` | Check map key | `{{if hasKey .rawData "data"}}` |
| `len` | Get length | `{{if eq (len $items) 0}}` |
| `toJson` | Safe JSON output | `{{$value \| toJson}}` |

---

## Common Gotchas

### Empty Arrays Are Truthy

```go
// BAD - empty array passes
{{if $items}}

// GOOD - check length
{{if gt (len $items) 0}}
```

### Missing Key Access

```go
// BAD - errors if key doesn't exist
{{.rawData.data}}

// GOOD - check key first
{{if hasKey .rawData "data"}}{{.rawData.data}}{{end}}
```

### Type Mismatch

```go
// BAD - fails if field is object not string
{{$item.address}}

// GOOD - check type first
{{if kindIs "string" $item.address}}{{$item.address}}{{end}}
```

---

## Multiple Request Patterns

### Multiple URLs

A URL template can create multiple requests by outputting each URL on a new line:

```go
{{- range .customer.emailAddresses -}}
https://api.example.com/customers?email={{urlquery .}}
{{ end -}}
```

### Multiple Bodies

Use `#body` marker for multiple request bodies (for POST requests):

```go
{{- range .customer.emailAddresses -}}
#body
{
    "emailAddress": "{{.}}"
}
{{ end -}}
```

**Important:** Template actions after URL or body text must not strip the newline. The `{{` following should not include `-`.

---

## Testing Framework

### Test Directory Structure

```
_test_/{test dataset name}/
├── integration.json           # Test: integration.configuration and secrets
├── customer.json              # Test: customer profile data (root pulls)
├── externalData.json          # Test: data from dependent pulls
├── rawData.json               # Test: API response to transform
├── expected_request_url.txt   # Expected URL output
├── expected_request_body.*    # Expected body (json, txt, or bin)
└── expected_response_transformation.json
```

### File Inheritance

Test datasets inherit files from their parent `_test_/` directory. Files in the dataset subdirectory override inherited files.

### Testing Metadata Templates

For `external_id.gtpl` and `external_parent_id.gtpl`, use `externalData.json`:

```json
{
    "order": [
        {"orderId": "order1", "customerId": "customer1"},
        {"orderId": "order2", "customerId": "customer2"}
    ]
}
```

The expected output lists one value per line:

```
order1
order2
```

### Edge Case Test Fixtures

Create fixtures for:

1. **Empty results**: `_test_/empty_results/`
   ```json
   {"rawData": {"data": []}}
   ```

2. **Null fields**: `_test_/null_fields/`
   ```json
   {"rawData": {"data": [{"id": "1", "note": null, "tags": null}]}}
   ```

3. **Missing parent**: `_test_/no_customer/`
   ```json
   {"externalData": {"acme_customer": []}}
   ```

### Regex Pattern Matching in Tests

Expected `.txt` files can use regex patterns by wrapping the content in `/regex/` delimiters:

```
/https:\/\/api\.example\.com\/customers\?email=.+@.+\..+/
```

This is useful when:
- URLs contain dynamic values (timestamps, UUIDs)
- Order of query parameters may vary
- Testing pattern compliance rather than exact values

**Example:** Testing a URL with encoded email:

```
/https:\/\/api\.acme\.com\/v1\/customers\?email=[^&]+%40[^&]+/
```

---

## CLI Commands

```bash
# Test all data pulls
appcfg test data-pull --root .

# Test specific data pull
appcfg test data-pull orders --root .

# Real API testing
appcfg data-graphql
```
